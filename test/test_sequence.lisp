;;; -*- mode: lisp; coding: utf-8 -*- 
;;; test_sequence.lisp --- a bunch of forms with which ISLisp processor must return true.

;; Copyright (C) 2017, 2018 Yuji Minejima <yuji@minejima.jp>

;; This file is part of ISLisp processor KISS.

;; KISS is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; KISS is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.


;;; length
(eql (length '(a b c)) 3)
(eql (length '(a (b) (c d e))) 3)
(eql (length '()) 0)
(eql (length '(1 2 3 4 5 6 7 8 9 10)) 10)
(eql (length '(a b . c)) 2)
(eql (length (vector 'a 'b 'c)) 3)
(eql (length #()) 0)
(eql (length #(x y z)) 3)
(eql (length "") 0)
(eql (length "Here I am, JH.") 14)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <domain-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(length 'not-a-sequence))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <domain-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(length #2A((a b c) (x y z))))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <domain-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(length (create-array '())))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <arity-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(length))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <arity-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(length '() "abc"))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <arity-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(length #(x y z) '() "abc"))
  nil)


;;; elt
(eq (elt '(a b c) 0) 'a)
(eq (elt '(a b c) 1) 'b)
(eq (elt '(a b c) 2) 'c)
(eq (elt (vector 'a 'b 'c) 0) 'a)
(eq (elt (vector 'a 'b 'c) 1) 'b)
(eq (elt (vector 'a 'b 'c) 2) 'c)
(eql (elt "abc" 0) #\a)
(eql (elt "abc" 1) #\b)
(eql (elt "abc" 2) #\c)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(elt "abc" -1))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(elt "abc" 3))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(elt "" 0))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(elt #() 0))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(elt '() 0))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <domain-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(elt 'not-a-sequence 0))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <domain-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(elt "abc" 'x))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <arity-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(elt))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <arity-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(elt "abc"))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <arity-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(elt "abc" 0 1))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <arity-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(elt "abc" 0 1 2))
  nil)


;;; set-elt
(string= (let ((string (create-string 5 #\x)))
	   (set-elt #\O string 2)
	   string)
	 "xxOxx")
(equal (let ((x (create-list 3 'x)))
	 (set-elt 'y x 1)
	 x)
       '(x y x))
(equal (let ((x (vector 'a 'b 'c)))
	 (set-elt 'z x 1)
	 x)
       '#(a z c))
(defglobal vec (vector 'a 'b 'c))
(eq (set-elt 'x vec 0) 'x)
(equal vec #(x b c))
(eq (set-elt 'y vec 1) 'y)
(equal vec #(x y c))
(eq (set-elt 'z vec 2) 'z)
(equal vec #(x y z))
(defglobal list (list 'a 'b 'c))
(eq (set-elt 'x list 0) 'x)
(equal list '(x b c))
(eq (set-elt 'y list 1) 'y)
(equal list '(x y c))
(eq (set-elt 'z list 2) 'z)
(equal list '(x y z))
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <domain-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(set-elt 'x 'not-a-sequence 0))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <domain-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(set-elt 'x (list 'a 'b 'c) 'z))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <domain-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(set-elt 'z (list 'a 'b 'c) -1))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <domain-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(set-elt 'z (list 'a 'b 'c) 3))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <domain-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(set-elt 'z (list) 0))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <domain-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(set-elt 'z (vector) 0))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <domain-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(set-elt 'z (create-string 0) 0))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <arity-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(set-elt))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <arity-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(set-elt 'x))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <arity-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(set-elt 'x (list 'a 'b 'c)))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <arity-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(set-elt 'x (list 'a 'b 'c) 0 1))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <arity-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(set-elt 'x (list 'a 'b 'c) 0 1 2))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <arity-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(set-elt 'x (list 'a 'b 'c) 0 1 2 3))
  nil)


;; subseq
(equal (subseq "abcdef" 1 4) "bcd")
(equal (subseq "abcdef" 0 6) "abcdef")
(equal (subseq "abcdef" 0 2) "ab")
(equal (subseq "abcdef" 3 6) "def")
(equal (subseq "abcdef" 0 0) "")
(equal (subseq "abcdef" 3 3) "")
(equal (subseq "abcdef" 6 6) "")
(equal (subseq '(a b c d e f) 1 4) '(b c d))
(equal (subseq '(a b c d e f) 0 1) '(a))
(equal (subseq '(a b c d e f) 0 6) '(a b c d e f))
(equal (subseq '(a b c d e f) 3 6) '(d e f))
(equal (subseq '(a b c d e f) 5 6) '(f))
(equal (subseq '(a b c d e f) 0 0) '())
(equal (subseq '(a b c d e f) 3 3) '())
(equal (subseq '(a b c d e f) 6 6) '())
(equal (subseq (vector 'a 'b 'c 'd 'e 'f) 1 4) #(b c d))
(equal (subseq (vector 'a 'b 'c) 0 1) #(a))
(equal (subseq (vector 'a 'b 'c) 0 2) #(a b))
(equal (subseq (vector 'a 'b 'c) 0 3) #(a b c))
(equal (subseq (vector 'a 'b 'c) 2 3) #(c))
(equal (subseq (vector 'a 'b 'c) 1 3) #(b c))
(equal (subseq "" 0 0) "")
(equal (subseq #() 0 0) #())
(equal (subseq '() 0 0) nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <domain-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(subseq 'not-a-sequence 0 0))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <domain-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(subseq #(a b c) 'z 0))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <domain-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(subseq #(a b c) 0 'z))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(subseq #(a b c) 1 0))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <domain-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(subseq #(a b c) 0 100))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <domain-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(subseq #(a b c) -1 1))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <arity-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(subseq))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <arity-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(subseq "abc"))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <arity-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(subseq "abc" 0))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <arity-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(subseq "abc" 0 1 2))
  nil)
(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <arity-error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(subseq "abc" 0 1 2 3))
  nil)


;;; map-into
(equal (let ((a (list 1 2 3 4))
	     (b (list 10 10 10 10)))
	 (map-into a #'+ a b))
       '(11 12 13 14))
(equal (let ((a (list 11 12 13 14))
	     (k (list 'one 'two 'three)))
	 (map-into a #'cons k a))
       '((one . 11) (two . 12) (three . 13) 14))
(equal (let ((a (list '(one . 11) '(two . 12) '(three . 13) 14))
	     (x 0))
	 (map-into a (lambda () (setq x (+ x 2)))))
       '(2 4 6 8))
(equal (let ((a (list '(one . 11) '(two . 12) '(three . 13) 14))
	     (x 0))
	 (map-into a (lambda () (setq x (+ x 2))) '()))
       '((one . 11) (two . 12) (three . 13) 14))
(equal (let ((list (list 0 1 2 3 4 5))
             (a (list 'a 'b 'c))
             (b (list 'x 'y 'z))
             (c (list 9 8 7)))
         (map-into list (lambda (i j k) (list i j k)) a b c))
       '((a x 9) (b y 8) (c z 7) 3 4 5))
(equal (let ((list '())
             (a (list 'a 'b 'c))
             (b (list 'x 'y 'z))
             (c (list 9 8 7)))
         (map-into list (lambda (i j k) (list i j k)) a b c))
       '())
(equal (let ((list (list 0))
             (a (list 'a 'b 'c))
             (b (list 'x 'y 'z))
             (c (list 9 8 7)))
         (map-into list (lambda (i j k) (list i j k)) a b c))
       '((a x 9)))
(equal (let ((list (list 0 1))
             (a (list 'a 'b 'c))
             (b (list 'x 'y 'z))
             (c (list 9 8 7)))
         (map-into list (lambda (i j k) (list i j k)) a b c))
       '((a x 9) (b y 8)))
(equal (let ((list (list 0 1))
             (a (list 'a))
             (b (list 'x 'y 'z))
             (c (list 9 8 7)))
         (map-into list (lambda (i j k) (list i j k)) a b c))
       '((a x 9) 1))
(equal (let ((list (list 0 1))
             (a '())
             (b (list 'x 'y 'z))
             (c (list 9 8 7)))
         (map-into list (lambda (i j k) (list i j k)) a b c))
       '(0 1))
(equal (let ((list (list 0 1 2))
             (a (list 'a 'b 'c))
             (b (list 'x 'y 'z))
             (c (list 9 8 7 8 9 10)))
         (map-into list (lambda (i j k) (list i j k)) a b c))
       '((a x 9) (b y 8) (c z 7)))

(equal (let ((a (vector 1 2 3 4))
	     (b (vector 10 10 10 10)))
	 (map-into a #'+ a b))
       #(11 12 13 14))
(equal (let ((a (vector 11 12 13 14))
	     (k (vector 'one 'two 'three)))
	 (map-into a #'cons k a))
       #((one . 11) (two . 12) (three . 13) 14))
(equal (let ((a (vector '(one . 11) '(two . 12) '(three . 13) 14))
	     (x 0))
	 (map-into a (lambda () (setq x (+ x 2)))))
       #(2 4 6 8))
(equal (let ((a (vector '(one . 11) '(two . 12) '(three . 13) 14))
	     (x 0))
	 (map-into a (lambda () (setq x (+ x 2))) '()))
       #((one . 11) (two . 12) (three . 13) 14))
(equal (let ((vector (vector 0 1 2 3 4 5))
             (a (vector 'a 'b 'c))
             (b (vector 'x 'y 'z))
             (c (vector 9 8 7)))
         (map-into vector (lambda (i j k) (list i j k)) a b c))
       #((a x 9) (b y 8) (c z 7) 3 4 5))
(equal (let ((vector #())
             (a (vector 'a 'b 'c))
             (b (vector 'x 'y 'z))
             (c (vector 9 8 7)))
         (map-into vector (lambda (i j k) (list i j k)) a b c))
       #())
(equal (let ((vector (vector 0))
             (a (vector 'a 'b 'c))
             (b (vector 'x 'y 'z))
             (c (vector 9 8 7)))
         (map-into vector (lambda (i j k) (list i j k)) a b c))
       #((a x 9)))
(equal (let ((vector (vector 0 1))
             (a (vector 'a 'b 'c))
             (b (vector 'x 'y 'z))
             (c (vector 9 8 7)))
         (map-into vector (lambda (i j k) (list i j k)) a b c))
       #((a x 9) (b y 8)))
(equal (let ((vector (vector 0 1))
             (a (vector 'a))
             (b (vector 'x 'y 'z))
             (c (vector 9 8 7)))
         (map-into vector (lambda (i j k) (list i j k)) a b c))
       #((a x 9) 1))
(equal (let ((vector (vector 0 1))
             (a '())
             (b (vector 'x 'y 'z))
             (c (vector 9 8 7)))
         (map-into vector (lambda (i j k) (list i j k)) a b c))
       #(0 1))
(equal (let ((vector (vector 0 1 2))
             (a (vector 'a 'b 'c))
             (b (vector 'x 'y 'z))
             (c (vector 9 8 7 8 9 10)))
         (map-into vector (lambda (i j k) (list i j k)) a b c))
       #((a x 9) (b y 8) (c z 7)))

(string= (let ((string (create-string 4 #\z)))
           (map-into string (lambda (x) x) "abc"))
         "abcz")
(string= (let ((string (create-string 4 #\z)))
           (map-into string (lambda () #\X)))
         "XXXX")
(string= (let ((string (create-string 4 #\z)))
           (map-into string (lambda (x) x) "abcdefghijklmnopqrstuvwxyz"))
         "abcd")
(string= (let ((string (create-string 0 #\z)))
           (map-into string (lambda (x) x) "abcdefghijklmnopqrstuvwxyz"))
         "")



(block top
  (with-handler (lambda (condition)
		  (if (instancep condition (class <error>))
		      (return-from top t)
		    (signal-condition condition nil)))
		(map-into 'not-a-sequence (lambda (x) (+ x 1)) (list 0 1 2 3))))
